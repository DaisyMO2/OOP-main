class profile:
    def __init__ (
        self, name, favorite_language, hobby, tech_stack, github_username, fun_fact):
        self.name = name
        self.favorite_language = favorite_language
        self.hobby = hobby 
        self.tech_stack = tech_stack
        self.github_username = github_username
        self.fun_fact = fun_fact
        
    def introduce(self):
        print(
            f"hi, i am {self.name}. i love {self.favorite_language} and my hobby is {self.hobby}."
        )
        print(f"fun fact about me: {self.fun_fact}")
        
    def show_stack(self):
        print(f"{self.name}'s tech stack:")
        for i, tool in enumerate(self.tech_stack, start=1):
            print(f"{i}. {tool}")
            
    def github_link(self):
        return f"https://github.com/{self.github_DaisyMO2}"
    
    

#creating my profile
my_profile = profile(
    name="Daisy Marunga",
    favorite_language="python",
    hobby="watching movies",
    tech_stack=["canva", "javascript", "CSS", "React", "HTML", "Next.js"],
    github_username="DaisyMO2", 
    fun_fact="i love cooking !",
)

#calling the methods
my_profile.introduce()
print()
my_profile.show_stack()
print()
print("github profile:", my_profile.github_link())

#!/usr/bin/env python3
"""
Task Manager
A single-file, self-contained CLI task manager.
Features:
- add, list, show, complete, remove tasks
- tags and priorities
- due dates with ISO format YYYY-MM-DD
- search and filter by tag, priority, due date range, status
- recurring tasks (daily, weekly, monthly)
- import/export JSON
- simple persistence to file tasks_db.json
- built-in unit tests, run with --run-tests

Usage examples:
python task_manager.py add "Buy milk" --tags grocery,home --priority 2 --due 2025-11-01
python task_manager.py list --tag grocery --status open
python task_manager.py export tasks_export.json

Author: Generated by assistant
"""

from __future__ import annotations
import argparse
import json
import os
import sys
from dataclasses import dataclass, field, asdict
from datetime import datetime, date, timedelta
from typing import List, Optional, Dict, Any
import uuid
import unittest

DB_FILENAME = 'tasks_db.json'
DATE_FORMAT = '%Y-%m-%d'

# ---------- Models ----------

@dataclass
class Task:
    id: str
    title: str
    notes: Optional[str] = None
    tags: List[str] = field(default_factory=list)
    priority: int = 3
    created_at: str = field(default_factory=lambda: datetime.utcnow().isoformat())
    due: Optional[str] = None
    completed_at: Optional[str] = None
    recurring: Optional[str] = None  # 'daily', 'weekly', 'monthly'

    def is_completed(self) -> bool:
        return self.completed_at is not None

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

    @staticmethod
    def from_dict(data: Dict[str, Any]) -> 'Task':
        return Task(**data)

    def due_date(self) -> Optional[date]:
        if not self.due:
            return None
        return datetime.strptime(self.due, DATE_FORMAT).date()

    def mark_complete(self) -> None:
        self.completed_at = datetime.utcnow().isoformat()

    def schedule_next(self) -> Optional['Task']:
        if not self.recurring or not self.due:
            return None
        try:
            current = datetime.strptime(self.due, DATE_FORMAT).date()
        except Exception:
            return None
        if self.recurring == 'daily':
            nxt = current + timedelta(days=1)
        elif self.recurring == 'weekly':
            nxt = current + timedelta(weeks=1)
        elif self.recurring == 'monthly':
            # naive month increment
            month = current.month + 1
            year = current.year
            if month > 12:
                month = 1
                year += 1
            day = min(current.day, 28)
            nxt = date(year, month, day)
        else:
            return None
        new_task = Task(
            id=str(uuid.uuid4()),
            title=self.title,
            notes=self.notes,
            tags=list(self.tags),
            priority=self.priority,
            due=nxt.strftime(DATE_FORMAT),
            recurring=self.recurring,
        )
        return new_task


# ---------- Storage ----------

class TaskDB:
    def __init__(self, filename: str = DB_FILENAME):
        self.filename = filename
        self.tasks: Dict[str, Task] = {}
        self._load()

    def _load(self) -> None:
        if not os.path.exists(self.filename):
            self.tasks = {}
            return
        with open(self.filename, 'r', encoding='utf-8') as f:
